참고링크:https://jboss6.openmaru.io/docs/09.Datasource_SubSystem.html
default 프로파일
<default>
logging
configadmin
security
datasources
infinispan
jpa
weld
webservices
ee
ejb3
transactions
mail


<default-ha>
+jgroups,modcluster

<full>
cmp,jacorb,jaxr,messaging

<full-ha>
full + jgroups modcluster

스탠드얼론모드는 하나의 Java VM프로세스로 JBoss 인스턴스를 구성하는 관리 모델
JVM이란 자바 가상머신으로 자바 바이트 코드를 실행할 수 있는 주체
운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가
이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을한다.
JBoss 시작 스크립트를 실행하면 하나의 JBoss 인스턴스가 실행되고,
각 인스턴스마다 관리작업을 수행한다.
만약 스탠드얼론모드로 여러개의 독립적인 인스턴스가 시작되어
서버들을 관리해야하는 경우에 관리자는 각각의 인스턴스를 개별적으로 관리할 수 밖에 없다.

도메인모드는 하나의 도메인 컨트롤러를 통해 관리
도메인 컨트롤러는 자바 프로세스로 관리자가 웹 콘솔,cli등 관리도구를 사용하여
도메인 컨트롤러에 접속하여 도메인 전체 관리 작업을 수행할 수 있다.

도메인 모드에는 각 머신 즉 호스트 별로 호스트컨트롤러 라는 프로세스가 존재.
이 호스트 컨트롤러는 도메인 컨트롤러에 연결하여 도메인 컨트롤러의 오퍼레이션(각종 설정 값의 관리 배포)등을 자신이 관리하는 서버에 반영하는 역할을 한다.

도메인 모드에서는 동일한 구성을 적용하는 인스턴스의 그룹을 서버 그룹이라고 부른다.
도메인 컨트롤러와 호스트 컨트롤러가 연결되어 도메인에 포함되는 서버 그룹과 그 서버 그룹에 포함되는 서버 인스턴즈 정보를 관리한다.
도메인 모드에서 서버 그룹은 자동적으로 클러스터로서 구축되기 때문에 스탠드얼론모드와 같이 클러스터를 별도로 정의할 필요가 없다.
어플리케이션은 서버 그룹단위로 애플리케이션 배포 관리 한다.

도메인 모드로 시작된 서버들에 대해서 클러스터링을 활성화하려면 domain.xml을 업데이트하고 ha프로필과 ha-sockets 소켓 바인딩
그룹을 사용하도록 서버 그룹을 지정한다.

도메인 모드의 가장 큰 특징은 여러 개의 JBoss 인스턴스를 '하나의 관리 단위'로 묶어 관리하는 기능이다.
도메인 기능을 사용하면 단일한 관리 인터페이스를 통해 여러 개의 JBoss 인스턴스에 대한 설정 변경이나 애플리케이션 배포등의 관리 오퍼레이션을 실행 할 수 있다.


<클래스로더 및 모듈 소개>
JBoss EAP 6에서는 배포된 애플리케이션의 클래스 패스를 제어하기 위한 새로운 모듈 형식의 클래스 로드 시스템을 사용한다.
개발자가 애플리케이션에서 사용할 수 있는 클래스에 대해 상세한 제어가 가능하여
애플리케이션 서버에서 제공하는 클래스를 무시하고 자신의 클래스를 사용하도록 설정할 수 있다.

모듈 형식의 클래스 로더는 모든 JAVA클래스를 모듈이라는 논리 그룹으로 나눈다.
각 모듈은 자신의 클래스 패스에 추가된 모듈에서 다른 모듈 의존성을 정의할 수 있다.
모듈 시스템은 JBoss EAP 6에 패키지 된 모든 Java 클래스와 배포된 애플리케이션의 Java 클래스에 적용된다.

JAR,WAR파일도 모듈로 취급하기 때문에 개발자는 모듈 설정과 의존성을 추가하여 애플리케이션의 클래스 패스 내용을 쉽게 제어할 수 있다.

클래스를 로드할 때 묶음 단위,
일반적으로 하나의 jar 파일
여러 개의 jar파일이나 프로퍼티 파일 등 자원을 포함할 수 있다.
모듈 하나에 대해서 하나의 클래스 로더
각 모듈은 런타임에 필요한 의존 모듈을 정의
계층형 클래스 로더 구조가 아닌 그래프 클래스 로더 구조
'클래스 패스'는 없음.


모듈이 두 가지 있는데 정적모듈과 동적모듈
(Module 디렉터리에 저장방식)
(다이나믹 모듈 저장방식) 



배포 시 클래스 로딩
클래스 로더의 이해
클래스는 사용되기 전에 반드시 클래스 로더를 통해 JVM의 메모리 영역에 로드된다.
클래스 로더를 이해하는 데 가장 중요한 개념은 '위임 모델'이다.


클래스 로더는 필요시 부모 클래스 로더에 클래스의 로드를 부탁하는 구조, 즉 맡기는(위임) 것이다. 예를 들어, 
시스템 클래스 로더가 클래스를 로드하려고 할 때 시스템 클래스 로더는 자신의 로컬 클래스 패스, 
즉 환경변수 CLASSPATH에서 찾기 전에 먼저 부모인 확장 클래스 로더에 클래스의 로드를 요청하게 된다
. 마찬가지로 확장 클래스 로더도 먼저 부모 클래스 로더인 부트 스트랩 클래스 로더에 클래스의 로드를 위임하게 된다. 
부모 클래스 로더에서 클래스가 발견된 경우에 거기서 클래스를 로딩하여 종료하게 된다. 부모에 클래스가 없을 때
 비로소 자신의 로컬 클래스 패스를 찾게 되고 클래스를 로드하게 된다. 위임 모델에서 중요한 것은 자식이 먼저하는 것이 아니라 먼저 부모에게 위임하는 것이다.


WAR배포
WAR패키지가 하나의 모듈로 간주된다.
WEB-INF/lib 디렉터리의 파일들은 WEB-INF/classes 디렉터리에 있는
클래스와 동일하게 처리된다. WAR로 패키지 된 클래스들은 동일한 클래스 로더에 로드된다.

JBoss 모듈 클래스 로더는 우선순위 구조를 이용하여 클래스 로딩 충돌이 발생하지 않도록 한다.

배포시 패키지와 클래스들의 리스트는 각각의 배포와 해당 종속성에 의해 생성된다.

클래스로더를 하는데



JVM실행될 때 젤 먼저 실행되는 클래스로더인 부트 스트랩은
서비스 컨트롤러에 의해 서버 서비스의 부팅을 처리하는일로 시작함.
1.부트시 설정파일 standalone.xml을 읽고
2.<extension>에 정의된 모듈의 이름을 찾는데 그 찾는 방식은
$JBOSS_HOME/modules 디렉토리에서 모듈 ㅣㅇ름에 해당하는 모듈을 로딩

모듈을 로딩하면(디렉토리에 있는 module.xml) 모듈에 정의된 xml 스키마를 읽어
모듈을 초기화하고(선언?) 이 모듈은 어떤 XML 네임스페이스를 사용할 것인지 구현하고 있어
XML 스키마를 읽어 msc에서 서브시스템을 시작한다.

아파치의 가상 호스트(Virtual Host)의 설정과 같은 기능을 제공하는 것이 JBoss EAP 6에서는 가상 서버이다. 일반적으로 JBoss EAP 6 앞단에 아파치 웹 서버를 구성하는 경우가 많아서
 JBoss의 가상 서버보다는 웹 서버의 가상 호스트기능을 사용하여 설정하는 경우가 많다.

데이터소스
데이터베이스에 연결하는 방법을 캡슐화 한 것
RDBMS와 상관없이 공통의 인터페이스를 사용해 연결할 수 있도록 하는 방식



데이터베이스 드라이버나 URL에 대한 정보를 애플리케이션에서 분리하여
서버 측에서 별도로 관리하기 때문에, 애플리케이션은 데이터소스를 네이밍 서비스에서 룩업하여 가져다가 데이터베이스 연결을 사용할 수 있다. 

데이터베이스와의 연결 관리는 클라이언트 애플리케이션이 아닌 JBoss EAP 6에서 하게 된다. 
비교적 비용이 많이 소요되는 데이터베이스와의 연결도 풀 형태로 관리하여 데이터베이스 연결에 대한 부하를 최소화한다.


XA 데이터소스는 하나의 트랜잭션이 여러 데이터베이스에 걸쳐 사용되는 경우에 사용된다.
 그래서 XA 데이터소스를 사용하게 되면 오버 헤드가 늘어나게 된다.


데이터소스는 애플리케이션과 Connection Pool 사이의 인터페이스이다. 
애플리케이션이 사용하는 데이터소스 객체는 DB 커넥션들의 Factory로 볼 수 있으며 java.sql.DriverManager 보다 많은 이점을 제공한다.


JTA란 
플랫폼마다 상이한 트랜잭션 매니저들과 어플리케이션들이 상호작용 할 수 있는 인터페이스를 정의하고 있음.
JAVA에서 제공되는 대부분의 API와 마찬가지로, JTA는 실제 구현은 다르지만 어플리케이션이 공통적으로
사용할 수 있는 하나의 인터페이스를 제공함.
트랜잭션 처리가 필요한 어플리케이션이 특정 벤더의 트랜잭션 매니저에 의존할 필요가 없음.

XA 역시 하나의 표준 모든 호환되는 데이터 저장소들이 전역 트랜잭션의 부분으로서 트랜잭션 매니저와 연동 할 수 있다.
XA는 트랜잭션 매니저와 데이터 저장소를 연결해 주는 역할 담당.




<데이터소스 connection pool 공통 파라미터>
애플리케이션에서 DB커넥션이 병목이 되는 경우,
커넥션 풀 설정을 한다.

min-pool-size: 커넥션 풀에서 유지하는 최소 연결 수
지정한 커넥션 수만큼 풀에서 커넥션을 생성하지만 시기는 prefill 속성에 따라 다름

max-pool-size:커넥션 풀에서 유지하는 최대 연결 수 
prefill:커넥션 풀을 미리 채우도록 설정

데이터소스를 작성할 때 min-pool-size로 지정된 수의 연결을 미리 맺어
풀안에 확보할 것인지를 true/false로 지정함

prefill이 true인 경우에는 min-pool-size 개수 만큼의 연결이 풀에 생성
false인경우 최초의 커넥션이 연결될 때 min-pool-size에 지정된 수만큼 커넥션이 생성

flush-strategy:연결에 오류가 있는 경우 풀에 있는 연결에 대한 처리 방법을 설정한다.설정할 수 있는 옵션은
FallingConnectionOnly: 연결 오류가 발생한 연결만 제거
IdleConnections: idle 상태의 연결을 제거한다.
EntirePOOl:모든 연결을 제거



min-pool-size과 max-pool-size을 같게 설정하는 이유
일반적으로 커넥션 풀의 최솟값은 시스템의 일반적인 운영 상태에서 정상적인 DB 동시 액세스 수나 성능 요건에 따라 값을 지정한다.

커넥션 풀의 최댓값은 장애가 발생할 때나 피크 시간에서 DB에 동시 접근할 수 있도록 여유 있는 값을 설정한다.
 DB 서버 성능 요건 (동시에 몇 개의 트랜잭션를 처리할 수 있는지)에 따라 제한하는 등 시스템에 따라 설정 값을 지정한다.

실제의 운영이나 부하 테스트 시 애플리케이션이 DB 커넥션을 얻기 위해 대기하는 시간이 문제가 되는 경우 연결 풀의 최댓값을 늘린다.

pool-prefill 속성에 대해서는 애플리케이션이 맨 처음DB 연결 시 연결 대기 시간이 발생하는 것이 시스템상 문제가 되는 경우 true로 설정한다.


<메시징 서브시스템>
Java Message Service(JMS)를 제공하기 위한 서브시스템


대부분 요청을 보내면 응답이 오기까지 기다리는 동기 처리에 익숙하여서, 요청을 보낸 후 응답을 기다리지 않고 곧바로 다른 일을 처리하는 비동기 처리에 대해 막연히 불안하게 생각될 수 있다.

비동기 처리에 대해 자주 예로 드는 것이 메일이다. 일상생활에서 종이로 보내는 메일이나 전자메일 모두 보내는 즉시 답변 메일이 오는 것이
 아녀서 기다리지 않는다. 반면 전화는 실생활에서 경험할 수 있는 대표적인 동기 처리의 예이다. 통화 상대가 다른 일을 하고 있었더라도 연결되면 전화 통화를 시작하게 된다.

엔터프라이즈 시스템에서는 일반적으로 메세지 큐 또는 MOM라고 부르는 비동기 메시징 시스템을 사용하여 여러 시스템 간에 메시지를 전송하여 처리하는
메시지 교환 시스템을 구현해왔다.

JMS는 Java 애플리케이션에서 이런 메시징 시스템을 구현하기 위한 표준
시스템 간 메시지 전송을 비동기로 설계하면 하드웨어 리소스 사용률이 줄어들고
io작업을 최소화하여 네트워크 대역폭을 더 적게 사용할 수 있다.

메시징 시스템은 메시지를 보내는 메시지 제공자와 메시지를 받는 메시지 소비자와 분리하여 처리한다.
JMS를 이용하여 여러 애플리케이션이 서로 메시지를 전송하여 통신할 수 있다.

대부분의 메시징 형태는 피어 투 피어형이고 JMS애플리케이션은 대부분 클라이언트가 된다.

JMS의 특징을 정리하면 다음과 같다.
Java 애플리케이셔에서 기존 MOM시스템과 메시지를 주고 받을 수 있다.
메시지를 작성하고 송수신하기 위한 표준 인터페이스가 제공되어 메시징 애플리케이션 개발이 쉬워진다.
표준화된 메시징 API를 사용하여 메시징 애플리케이션의 이식성을 높일 수 있다.


보안 도메인은 JBoss EAP 6의 보안 서브시스템의 일부이다.
보안 설정은 모든 관리 도메인의 도메인 컨트롤러나 스탠드얼론 모드에서 관리 할 수 있도록 한다.

보안 도메인은 인증,인가,맵핑,감사의 설정으로 구성된다.

인증은 사용자 신원을 확인하는 것
권한은 허가 또는 금지된 작업에 대한 정보가 포함된 보안 정책 보안에서는 역할이라고 한다.
보안 맵핑은 정보를 애플리케이션에 전달하기 전에 서브젝트(주체) 및 역할 특성에 대해 정보를 추가,편집,삭제하는 기능
감사는 보안 관련 이벤트를 보고하는 방법을 설정한다.

애플리케이션에서 보안 도메인을 사용하면 애플리케이션의 보안 모듈이나 프로그래밍으로 처리하던 부분을 제거할 수 있다.
애플리케이션에는 어떤 보안 도메인을 사용한다는 설정만 필요

보안 서브시스템 중 가장 많이 사용되는 것이 보안 도메인 기본적으로 jboss-ejb-policy,jboss-web-policy,other 3개 보안 도메인이 설정되어있음

보안 영역
보안영역은 인증이나 인가를 설정하는 곳으로 관리 인터페이스나 JMX,RMI 등에서 사용할 수 있다.
JBoss Eap 6에서는 다음과 같이 2개의 보안 영역이 설정되어 있다.

ManagementRealm
CLI나 관리 콘솔의 인증 방법이 설정되어있다. 기본적으로 mgmt-users.properties 파일을 사용하여 관리자를 설정

ApplicationRealm
RMI 인터페이스의 인증 방법을 규정함. 기본적으로 application-users.properties, application-roles.properties파일을 사용하도록 설정되있다.


cli나 관리인터페이스의 인증처리에 보안 영역을 사용함
기본적으로 설정된 'ManagementRealm'을 사용하는데 관리자가 접속하는 위치에 따라 동작이 다름
로컬 접속
cli에서 같은 서버에서 접근할 경우 인증 처리를 생략
리모트 접속
외부에서 접속할 경우 인증 처리함

ManagementRealm은 $JBOSS_HOME/configuration/mgmt-users.properties 파일을 사용하여 인증하도록 설정되어 있다. 이 파일의 패스워드는 암호화되어
 있기 때문에 직접 입력할 수 없고 앞서 설명한 add-user.sh 파일을 실행하여 관리자 ID와 패스워드를 추가해야 한다.



로깅은 애플리케이션의 활동을 일련의 메시지로 기록하는 것
jboss eap 6 로깅 시스템은 jboss logmanager를 기반으로 하고
다양한 로깅 프레임워크를 지원함.

또한 배포되는 애플리케이션에서 로깅 기능을 사용할 수 있도록 
jboss logging을 제공함


1.부트로거
로깅시스템도 extension으로 제공되는 모듈이기 때문에 로깅 서브시스템이 활성화되기 전까지(시스템로더->클래스로더->익스텐션->부트시스템)
이벤트를 기록할 로거가 필요. 부트 로거가 그 역할을 함.

로그 출력 레벨 및 로그 로테이션등이 이미 설정되어 있음.

부트로그
컨트롤러부트 쓰레드가 소켓바인딩을 통한 httpmanagement 서비스를 만듬
서버 부팅 순서


1..infinispan subsystem을 활성화(네트워크캐시 구현) 
네트워크 캐시를 두는 거 활성화시키고

infinispan- 캐시된 데이터를 관리하기위한 인터페이스 제공
두가지 모드가 있는데 embedded, server-client
embedded는 노드마다 애플리케이션의 라이브러리형태로 작동하여 동일한 jvm 안에서 애플리케이션과 전체 생명주기를 ㅏㅌ이함. (속도가 빠름 메모리상에 같이저장)
나머지 하나는 독립된 앱으로 실행하는 것


2.데이터소스커넥터를 배포.(활성화)
데베와 연결할 커넥터 배포


3. JCA subsystem이 시작되고 (비-관계형 리소스들로의 액세스를 표준화할 목적을 갖는 API)
JAVA CONNECTOR architecture (자바 응용프로그램과 엔터프라이즈 시스템간의 통신을 제공하는


4. jgroups 서브시스템이 활성화(클러스터링,고가용성을 위한 네트워크 라이브러리)



5.JSF Implementations을팔로우하는것을 활성화(웹 어플리케이션을 위한 컴포넌트 기반의 프레임워크)
앱을 개발하는데 있어 ui를 개발하기 쉽게하는 자바기반의 웹 앱 프레임워크
(java server face, 자카르타 서버 페이스,


6. 네이밍서브시스템을 활성화 및 스타트(jndi)

7. bound mail session

8. 보안 서브시스템을 활성화

9. 웹 서비스 익스텐션을 활성화

10.ajp포트를 스타트(coyote?),httpd 포트 열고

11. modcluster을 초기화
modcluster proxy포트 리스닝

12. jboss 배포 war파일 시작

13. 데이터 소스 바운드 (db드라이버등)
관련있는 웹 컨텍스트 등록


14. jgroups channel 시작하여 클러스러팅 목록 



기본적으로 server.log의 로그 디렉토리는 시스템 프로퍼티 "jboss.server.log.dir"에 의해 결정됨



<Infinispan>
jboss eap 6에서는 웹 앱 클러스터링 기능을 제공하기 위하여 jgroups와 infinsapan을 사용하고있다.

clustering 기능을 변경하려면 infinispan의 캐시 컨테이너 설정을 변경한다.
캐시 데이터 복제모드는 두 가지가있는데 replication방식과
일부 노드에만 복사하는 dist방식을 제공한다.

또한 통신모드는 동기방식과 비동기방식을 제공하고 있다.
기본 값은 replication,비동기모드

replication 모드
클러스터 그룹내의 모든 서버 노드에 캐시를 복제한다.
모든 노드에 복제하기 때문에
어느 서버 노드에 접속하더라도 서버의 로컬에서 캐시 데이터를 사용할 수 있다.

그러나 모든 서버 노드에 캐시 데이터를 복제하기 때문에 네트워크 트래픽이 많고,
모든 노드의 복제본을 가지기 때문에 메모리 사용량도 많다.

또 SYNC통신을 사용할 경우, 모든 서버 노드에 ㅐ해서 캐시 데이터 복제가 완료되어야 다음 작업을 처리할 수 있기 때문에, 서버 노드 수가 많아지면
캐시의 기록 속도가 느려져, 성능에 영향을 미치게 된다.



distribution모드
캐시의 복제 대상을 클러스터내의 일부 노드들을 대상으로 한다.
복제 대상 서버 노드 개수를 임의로 설정할 수 있다. 이를 캐시 오너 수라고한다.

복제 대상을 지정하지 않아도 내부 알고리즘으로 판단하여 각각의 캐시마다 분산하여 복제하는 점이 다르다.

Distribution 모드에서 캐시는 Consistent Hash알고리즘을 사용하여 관리한다.
캐시 복제 대상 갯수를 지정하여 사용하기 때문에 동기 통신을 사용하더라도, 캐시의 저장 속도에 영향을 덜 받게 된다.

consistent hash
분산 캐시에 사용하는 해시 알고리즘이다.
단순한 해시에 키를 추가,삭제했을 경우 , 테이블의 사이즈 변경이 필요해 키를 재 맵핑하는 시간이 오래걸리게 된다.

consistent hash를 이용하면 이 시간을 최소한으로 줄일 수 있다.
infinispan에서도 dist모드에서 어떤 노드에 데이터를 복제할지 결정하는데 이 알고리즘을 사용한다.
동적으로 노드의 갯수가 증가하고 줄어드는 환경에서 자동으로 데이터를 분산하기위해 사용하는 아로리즘이다.

캐시 데이터 복제

통신 방식
통신 방식은 비동기(ASYNC) 모드와 동기(SYNC)모드의 두 가지 종류가 있다.
비동기모드.
세션 복제시 비동기로 처리하여 응답 수신을 기다리지 않고 반환한다.
속도가 빠르다.

동기모드.
세션 복제시 모든 응답 수신이 완료되고 나서 응답을 준다.
백업까지 모두 성공적으로 된 것을 확인하기 때문에 신뢰성이 높다.
데이터 반영시 락을 걸고, 분산 2단계 커밋을 해서, 동일 데이터를 동시에 변경하면 에러가 발생한다.
속도가 상대적으로 느리다.



















 

































